// Generated by CoffeeScript 1.10.0
(function() {
  var Classifier, ClassifyPage, DecisionTree, DrawingTask, SubjectViewer,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Classifier = require('./classifier');

  SubjectViewer = require('./subject-viewer');

  DecisionTree = require('zooniverse-decision-tree');

  DrawingTask = require('./tasks/drawing');

  ClassifyPage = (function(superClass) {
    extend(ClassifyPage, superClass);

    ClassifyPage.prototype.workflow = 'untitled_workflow';

    ClassifyPage.prototype.tasks = null;

    ClassifyPage.prototype.firstTask = '';

    ClassifyPage.prototype.className = Classifier.prototype.className + " readymade-classify-page";

    ClassifyPage.prototype.template = require('./templates/classify-page');

    ClassifyPage.prototype.elements = {
      '.readymade-subject-viewer-container': 'subjectViewerContainer',
      '.readymade-decision-tree-container': 'decisionTreeContainer'
    };

    function ClassifyPage() {
      ClassifyPage.__super__.constructor.apply(this, arguments);
      this.subjectViewer = new SubjectViewer;
      this.subjectViewerContainer.append(this.subjectViewer.el);
      this.decisionTree = new DecisionTree({
        taskTypes: {
          radio: require('./tasks/radio'),
          checkbox: require('./tasks/checkbox'),
          button: require('./tasks/button'),
          filter: require('./tasks/filter'),
          drawing: DrawingTask
        },
        tasks: this.tasks,
        firstTask: this.firstTask || Object.keys(this.tasks)[0]
      });
      this.listenTo(this.decisionTree.el, this.decisionTree.LOAD_TASK, (function(_this) {
        return function(e) {
          return _this.subjectViewer.setTaskIndex(e.detail.index);
        };
      })(this));
      this.listenTo(this.decisionTree.el, DrawingTask.prototype.SELECT_TOOL, (function(_this) {
        return function(e) {
          var choice, ref, tool;
          ref = e.detail, tool = ref.tool, choice = ref.choice;
          return _this.subjectViewer.setTool(tool, choice);
        };
      })(this));
      this.listenTo(this.decisionTree.el, this.decisionTree.COMPLETE, (function(_this) {
        return function() {
          return _this.finishSubject();
        };
      })(this));
      this.decisionTreeContainer.append(this.decisionTree.el);
    }

    ClassifyPage.prototype.loadSubject = function(subject, callback) {
      var args;
      args = arguments;
      return this.subjectViewer.loadSubject(subject, (function(_this) {
        return function() {
          return ClassifyPage.__super__.loadSubject.apply(_this, args);
        };
      })(this));
    };

    ClassifyPage.prototype.loadClassification = function(classification, callback) {
      var args;
      args = arguments;
      this.decisionTree.reset();
      return this.subjectViewer.loadClassification(classification, (function(_this) {
        return function() {
          return ClassifyPage.__super__.loadClassification.apply(_this, args);
        };
      })(this));
    };

    ClassifyPage.prototype.sendClassification = function() {
      var annotation, i, len, ref;
      this.classification.set('workflow', this.workflow);
      ref = this.composeAnnotations();
      for (i = 0, len = ref.length; i < len; i++) {
        annotation = ref[i];
        this.classification.annotate(annotation);
      }
      return ClassifyPage.__super__.sendClassification.apply(this, arguments);
    };

    ClassifyPage.prototype.composeAnnotations = function() {
      var annotations, decisionTreeValues, i, j, key, keyAndValue, len, len1, mark, ref, value;
      annotations = [];
      decisionTreeValues = this.decisionTree.getValues();
      for (i = 0, len = decisionTreeValues.length; i < len; i++) {
        keyAndValue = decisionTreeValues[i];
        for (key in keyAndValue) {
          value = keyAndValue[key];
          annotations.push({
            key: key,
            value: value
          });
        }
      }
      ref = this.subjectViewer.markingSurface.tools;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        mark = ref[j].mark;
        if (!(annotations[mark._taskIndex].value instanceof Array)) {
          annotations[mark._taskIndex].value = [];
        }
        annotations[mark._taskIndex].value.push(mark);
      }
      return annotations;
    };

    return ClassifyPage;

  })(Classifier);

  module.exports = ClassifyPage;

}).call(this);
