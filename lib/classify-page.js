// Generated by CoffeeScript 1.7.1
(function() {
  var Classifier, ClassifyPage, DecisionTree, DrawingTask, SubjectViewer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Classifier = require('./classifier');

  SubjectViewer = require('./subject-viewer');

  DecisionTree = require('zooniverse-decision-tree');

  DrawingTask = require('./tasks/drawing');

  ClassifyPage = (function(_super) {
    __extends(ClassifyPage, _super);

    ClassifyPage.prototype.workflow = 'untitled_workflow';

    ClassifyPage.prototype.tasks = null;

    ClassifyPage.prototype.firstTask = '';

    ClassifyPage.prototype.className = "" + Classifier.prototype.className + " readymade-classify-page";

    ClassifyPage.prototype.template = require('./templates/classify-page');

    ClassifyPage.prototype.elements = {
      '.readymade-subject-viewer-container': 'subjectViewerContainer',
      '.readymade-decision-tree-container': 'decisionTreeContainer'
    };

    function ClassifyPage() {
      ClassifyPage.__super__.constructor.apply(this, arguments);
      this.subjectViewer = new SubjectViewer;
      this.subjectViewerContainer.append(this.subjectViewer.el);
      this.decisionTree = new DecisionTree({
        taskTypes: {
          radio: require('./tasks/radio'),
          checkbox: require('./tasks/checkbox'),
          button: require('./tasks/button'),
          filter: require('./tasks/filter'),
          drawing: DrawingTask
        },
        tasks: this.tasks,
        firstTask: this.firstTask || Object.keys(this.tasks)[0]
      });
      this.listenTo(this.decisionTree.el, this.decisionTree.LOAD_TASK, (function(_this) {
        return function(e) {
          return _this.subjectViewer.setTaskIndex(e.detail.index);
        };
      })(this));
      this.listenTo(this.decisionTree.el, DrawingTask.prototype.SELECT_TOOL, (function(_this) {
        return function(e) {
          var choice, tool, _ref;
          _ref = e.detail, tool = _ref.tool, choice = _ref.choice;
          return _this.subjectViewer.setTool(tool, choice);
        };
      })(this));
      this.listenTo(this.decisionTree.el, this.decisionTree.COMPLETE, (function(_this) {
        return function() {
          return _this.finishSubject();
        };
      })(this));
      this.decisionTreeContainer.append(this.decisionTree.el);
    }

    ClassifyPage.prototype.loadSubject = function(subject, callback) {
      var args;
      args = arguments;
      return this.subjectViewer.loadSubject(subject, (function(_this) {
        return function() {
          return ClassifyPage.__super__.loadSubject.apply(_this, args);
        };
      })(this));
    };

    ClassifyPage.prototype.loadClassification = function(classification, callback) {
      var args;
      args = arguments;
      this.decisionTree.reset();
      return this.subjectViewer.loadClassification(classification, (function(_this) {
        return function() {
          return ClassifyPage.__super__.loadClassification.apply(_this, args);
        };
      })(this));
    };

    ClassifyPage.prototype.sendClassification = function() {
      var annotation, _i, _len, _ref;
      this.classification.set('workflow', this.workflow);
      _ref = this.composeAnnotations();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        annotation = _ref[_i];
        this.classification.annotate(annotation);
      }
      return ClassifyPage.__super__.sendClassification.apply(this, arguments);
    };

    ClassifyPage.prototype.composeAnnotations = function() {
      var annotations, decisionTreeValues, key, keyAndValue, mark, value, _i, _j, _len, _len1, _ref;
      annotations = [];
      decisionTreeValues = this.decisionTree.getValues();
      for (_i = 0, _len = decisionTreeValues.length; _i < _len; _i++) {
        keyAndValue = decisionTreeValues[_i];
        for (key in keyAndValue) {
          value = keyAndValue[key];
          annotations.push({
            key: key,
            value: value
          });
        }
      }
      _ref = this.subjectViewer.markingSurface.tools;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        mark = _ref[_j].mark;
        if (!(annotations[mark._taskIndex].value instanceof Array)) {
          annotations[mark._taskIndex].value = [];
        }
        annotations[mark._taskIndex].value.push(mark);
      }
      return annotations;
    };

    return ClassifyPage;

  })(Classifier);

  module.exports = ClassifyPage;

}).call(this);
